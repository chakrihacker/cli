/**
 * @flow
 */

import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import chalk from 'chalk';
import glob from 'glob';
import sharp from 'sharp';
import {logger} from '@react-native-community/cli-tools';
import JsonFile from '@expo/json-file';

/*
 * Converts a raw number of bytes into a human readable value
 */
export const toReadableValue = (bytes: number) => {
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const index = Math.floor(Math.log(bytes) / Math.log(1024));
  const reduced = (bytes / Math.pow(1024, index)).toFixed(2);

  return `${reduced} ${sizes[index]}`;
};

/*
 * Calculate SHA256 Checksum value of a file based on its contents
 */
export const calculateHash = (file: string) => {
  const contents = fs.readFileSync(file);
  return crypto
    .createHash('sha256')
    .update(contents)
    .digest('hex');
};

/*
 * Compress an inputted jpg or png and save original copy with .orig extension
 */
export const optimizeImageAsync = async (
  image: string,
  newName: string,
  quality: number = 60,
) => {
  logger.log(`Optimizing ${image}`);
  // Rename the file with .orig extension
  fs.copyFileSync(image, newName);

  // Extract the format and compress
  const buffer = await sharp(image).toBuffer();
  const {format} = await sharp(buffer).metadata();
  if (format === 'jpeg') {
    await sharp(newName)
      .jpeg({quality})
      .toFile(image)
      .catch(err => logger.error(err));
  } else {
    await sharp(newName)
      .png({quality})
      .toFile(image)
      .catch(err => logger.error(err));
  }
};

/*
 * Returns a boolean indicating whether or not there are assets to optimize
 */
export const hasUnoptimizedAssetsAsync = async (
  projectDir: string,
  options: Object,
) => {
  if (
    !fs.existsSync(path.join(projectDir, '.reactnative-shared/assets.json'))
  ) {
    return true;
  }
  const {selectedImages} = await getAssetFilesAsync(projectDir, options);
  const {assetInfo} = await readAssetJsonAsync(projectDir);

  for (const file of selectedImages) {
    const hash = calculateHash(file);
    if (!assetInfo[hash]) {
      logger.info('inside if');
      return true;
    }
  }

  return false;
};

/*
 * Find all project assets
 * If --include of --exclude flags were passed in those results are filtered out.
 */
export const getAssetFilesAsync = async (
  projectDir: string,
  options: Object = {},
) => {
  const globOptions = {
    cwd: projectDir,
    ignore: ['**/node_modules/**', '**/ios/**', '**/android/**'],
    absolute: true,
  };
  const pattern = '**/*.*(jpg|png|jpeg)';
  const allImageAssets = glob.sync(pattern, globOptions);
  // If --include is passed in, only return files matching that pattern
  const included = options.include
    ? glob.sync(options.include, globOptions)
    : allImageAssets;
  const toExclude = new Set();
  if (options.exclude) {
    glob
      .sync(options.exclude, globOptions)
      .forEach(file => toExclude.add(file));
  }
  // If --exclude is passed in, filter out files matching that pattern
  const excluded = included.filter(file => !toExclude.has(file));
  const filtered = options.exclude ? excluded : included;
  return {
    allImages: allImageAssets,
    selectedImages: filterImages(filtered),
  };
};

/*
 * Formats an array of files to include the project directory and filters out PNGs and JPGs.
 */
const filterImages = files => {
  const regex = /\.(png|jpg|jpeg)$/;
  const allImages = files.filter(file => regex.test(file.toLowerCase()));
  return allImages;
};

/*
 * Read the contents of assets.json under .reactnative-shared folder. Create the file/directory if they don't exist.
 */
export const readAssetJsonAsync = async (projectDir: string) => {
  const dirPath = path.join(projectDir, '.reactnative-shared');
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath);
  }

  const assetJson: JsonFile<Object> = new JsonFile(
    path.join(dirPath, 'assets.json'),
  );
  if (!fs.existsSync(assetJson.file)) {
    const message =
      `Creating ${chalk.italic(
        '.reactnative-shared/assets.json',
      )} in the project's root directory.\n` +
      'This file is autogenerated and should not be edited directly.\n' +
      'You should commit this to git so that asset state is shared between collaborators.';

    logger.info(message);
    await assetJson.writeAsync({});
  }
  const assetInfo = await assetJson.readAsync();
  logger.info('assetInfo', assetInfo, typeof assetInfo);
  return {assetJson, assetInfo};
};

/*
 * Add .orig extension to a filename in a path string
 */
export const createNewFilename = (image: string) => {
  const {dir, name, ext} = path.parse(image);
  logger.info('dir', dir, 'name', name);
  return dir + '/' + name + '.orig' + ext;
};
